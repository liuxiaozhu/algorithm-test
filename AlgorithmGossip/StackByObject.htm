<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>





  
  
  
  
  
  <link rel="stylesheet" href="css/stdlayout.css" type="text/css">





  
  
  
  
  
  <link rel="stylesheet" href="css/print.css" type="text/css">





  
  
  
  
  
  <meta content="text/html; charset=UTF-8" http-equiv="content-type">





  
  
  
  
  
  <title>堆疊 - 使用 Java 作物件封裝</title>
</head>


<body>





<h3><a href="http://caterpillar.onlyfun.net/Gossip/index.html">From
Gossip@caterpillar</a></h3>





<h1><a href="AlgorithmGossip.htm">Algorithm Gossip:&nbsp;堆疊 - 使用 Java 作物件封裝</a></h1>





<h2>說明</h2>

如果您使用C++或Java等支援物件導向的語言來實作堆疊，您可以使用類別的方式來包括堆疊的功能，將所有的堆疊操作由堆疊物件來處理，一旦包裝完成，則使用堆疊物件的時候，只要呼叫加入、刪除等方法，而無需處理堆疊的top或判斷是否為空等細節。<br>

<h2>解法</h2>

使用C++與使用Java來作類別包裝其實是類似的，在這邊我們使用Java實作，因為它的語法看來較簡潔；Java雖然沒有指標，但可以使用參考（Reference）來達到鏈結的效果，一個節點的類別包裝方式如下：<br>

<div style="margin-left: 40px;"><span style="font-weight: bold; font-family: Courier New,Courier,monospace;">class Node { </span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;">

<span style="font-weight: bold; font-family: Courier New,Courier,monospace;">&nbsp;&nbsp;&nbsp; private int data;&nbsp;&nbsp; // 節點資料 </span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;">

<span style="font-weight: bold; font-family: Courier New,Courier,monospace;">&nbsp;&nbsp;&nbsp; private Node next;&nbsp; // 下一個節點位置 </span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;">

<br style="font-weight: bold; font-family: Courier New,Courier,monospace;">

<span style="font-weight: bold; font-family: Courier New,Courier,monospace;">&nbsp;&nbsp;&nbsp; public void setData(int data);&nbsp; // 節點資料 </span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;">

<span style="font-weight: bold; font-family: Courier New,Courier,monospace;">&nbsp;&nbsp;&nbsp; public void setNext(Node next);&nbsp; // 下一個節點位置 </span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;">

<span style="font-weight: bold; font-family: Courier New,Courier,monospace;">&nbsp;&nbsp;&nbsp; public int getData();&nbsp; // 傳回節點資料 </span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;">

<span style="font-weight: bold; font-family: Courier New,Courier,monospace;">&nbsp;&nbsp;&nbsp; public Node getNext();&nbsp; // 傳回下一個節點位置 </span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;">

<span style="font-weight: bold; font-family: Courier New,Courier,monospace;">}</span><br>

</div>

&nbsp;<br>

其中next是個物件參考名稱，它可以用來參考至（指向）下一個節點物件的記憶體位置，而堆疊類別可以如下包裝：<br>

<div style="margin-left: 40px;"><span style="font-weight: bold; font-family: Courier New,Courier,monospace;">class Stack { </span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;">

<span style="font-weight: bold; font-family: Courier New,Courier,monospace;">&nbsp;&nbsp;&nbsp; private Node top;&nbsp;&nbsp;&nbsp; // 堆疊頂端 </span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;">

<span style="font-weight: bold; font-family: Courier New,Courier,monospace;">&nbsp;&nbsp;&nbsp; private String name;&nbsp; // 只是個名稱 </span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;">

<br style="font-weight: bold; font-family: Courier New,Courier,monospace;">

<span style="font-weight: bold; font-family: Courier New,Courier,monospace;">&nbsp;&nbsp;&nbsp; // 利用建構子建立堆疊 </span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;">

<span style="font-weight: bold; font-family: Courier New,Courier,monospace;">&nbsp;&nbsp;&nbsp; public Stack(); </span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;">

<span style="font-weight: bold; font-family: Courier New,Courier,monospace;">&nbsp;&nbsp;&nbsp; public Stack(String name); </span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;">

<br style="font-weight: bold; font-family: Courier New,Courier,monospace;">

<span style="font-weight: bold; font-family: Courier New,Courier,monospace;">&nbsp;&nbsp;&nbsp; // 插入資料至頂端 </span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;">

<span style="font-weight: bold; font-family: Courier New,Courier,monospace;">&nbsp;&nbsp;&nbsp; public void add(int data); </span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;">

<br style="font-weight: bold; font-family: Courier New,Courier,monospace;">

<span style="font-weight: bold; font-family: Courier New,Courier,monospace;">&nbsp;&nbsp;&nbsp; // 傳回頂端資料 </span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;">

<span style="font-weight: bold; font-family: Courier New,Courier,monospace;">&nbsp;&nbsp;&nbsp; public int printTop(); </span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;">

<br style="font-weight: bold; font-family: Courier New,Courier,monospace;">

<span style="font-weight: bold; font-family: Courier New,Courier,monospace;">&nbsp;&nbsp;&nbsp; // 刪除頂端資料 </span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;">

<span style="font-weight: bold; font-family: Courier New,Courier,monospace;">&nbsp;&nbsp;&nbsp; public void del(); </span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;">

<br style="font-weight: bold; font-family: Courier New,Courier,monospace;">

<span style="font-weight: bold; font-family: Courier New,Courier,monospace;">&nbsp;&nbsp;&nbsp; // 列出堆疊內容 </span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;">

<span style="font-weight: bold; font-family: Courier New,Courier,monospace;">&nbsp;&nbsp;&nbsp; public void list(); </span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;">

<span style="font-weight: bold; font-family: Courier New,Courier,monospace;">}</span><br>

</div>

&nbsp;<br>

利用物件導向來包裝資料結構，雖然在設計時需要花較多的心思，但設計完成之後，日後呼叫使用就簡單了，以後您只要注意主程式的邏輯設計就可以了。<br>


<br>

<h2> 實作</h2>


<ul>

  <li> Java
  </li>

</ul>


<pre>import java.io.*; <br><br>// 節點 <br>class Node { <br>    private int data;   // 節點資料 <br>    private Node next;  // 下一個節點位置 <br><br>    public void setData(int data) {  // 節點資料 <br>        this.data = data; <br>    } <br><br>    public void setNext(Node next) {  // 下一個節點位置 <br>        this.next = next; <br>    } <br><br>    public int getData() {  // 傳回節點資料 <br>        return data; <br>    } <br><br>    public Node getNext() {  // 傳回下一個節點位置 <br>        return next; <br>    } <br>} <br><br>// 堆疊 <br>class Stack { <br>    private Node top; <br>    private String name;  // 只是個名稱 <br><br>    public Stack() { <br>        this("list"); <br>    } <br><br>    // 利用建構子建立堆疊 <br>    public Stack(String name) { <br>        this.name = name; <br>        top = null; <br>    } <br><br>    // 插入資料至頂端 <br>    public void add(int data) { <br>        Node newNode = new Node(); <br>        newNode.setData(data); <br>        newNode.setNext(top); <br>        top = newNode; <br>    } <br><br>    // 傳回頂端資料 <br>    public int printTop() { <br>        return top.getData(); <br>    } <br><br>    // 刪除頂端資料 <br>    public void del() { <br>        Node tmpNode; <br>        tmpNode = top; <br><br>        if(tmpNode == null) { <br>            System.out.println("\n堆疊已空！"); <br>            return; <br>        } <br><br>        top = top.getNext(); <br>        tmpNode = null; <br>    } <br><br>    // 列出堆疊內容 <br>    public void list() { <br>        Node tmpNode; <br>        tmpNode = top; <br><br>        System.out.print("\n堆疊內容："); <br>        while(tmpNode != null) { <br>            System.out.print(tmpNode.getData() + " "); <br>            tmpNode = tmpNode.getNext(); <br>        } <br>    } <br>} <br><br>public class StackShow { <br>    public static void main(String[] args) <br>                                  throws IOException { <br>        int input, select; <br>        BufferedReader buf; <br>        buf = new BufferedReader(<br>                       new InputStreamReader(System.in)); <br><br>        Stack s1 = new Stack("堆疊測試"); <br><br>        while(true) {  <br>            System.out.print("\n\n請輸入選項(-1結束)："); <br>            System.out.print("\n(1)插入值至堆疊"); <br>            System.out.print("\n(2)顯示堆疊頂端"); <br>            System.out.print("\n(3)刪除頂端值"); <br>            System.out.print("\n(4)顯示所有內容"); <br>            System.out.print("\n$c&gt;"); <br><br>            select = Integer.parseInt(buf.readLine()); <br><br>            if(select == -1) <br>                break; <br><br>            switch(select) { <br>                case 1: <br>                    System.out.print("\n輸入值："); <br>                    input = Integer.parseInt(buf.readLine()); <br>                    s1.add(input); <br>                    break; <br>                case 2: <br>                    System.out.print("\n頂端值：" +  <br>                                             s1.printTop()); <br>                    break; <br>                case 3: <br>                    s1.del(); <br>                    break; <br>                case 4: <br>                    s1.list(); <br>                    break; <br>                default: <br>                    System.out.print("\n選項錯誤！"); <br>            } <br>        } <br><br>        System.out.println(""); <br>    } <br>}</pre>

<br>





</body>
</html>
