<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>





  
  
  
  
  
  <link rel="stylesheet" href="css/stdlayout.css" type="text/css">





  
  
  
  
  
  <link rel="stylesheet" href="css/print.css" type="text/css">





  
  
  
  
  
  <meta content="text/html; charset=UTF-8" http-equiv="content-type">





  
  
  
  
  
  <title>費氏搜尋法</title>
</head>


<body>





<h3><a href="http://caterpillar.onlyfun.net/Gossip/index.html">From
Gossip@caterpillar</a></h3>





<h1><a href="AlgorithmGossip.htm">Algorithm Gossip:&nbsp;費氏搜尋法</a></h1>





<h2>說明</h2>

二分搜尋法每次搜尋時，都會將搜尋區間分為一半，所以其搜尋時間為O(log(2)n)，log(2)表示以2為底的log值，這邊要介紹的費氏搜尋，其利用費氏數列作為間隔來搜尋下一個數，所以區間收斂的速度更快，搜尋時間為O(logn)。<br>

<h2>解法</h2>

費氏搜尋使用費氏數列來決定下一個數的搜尋位置，所以必須先製作費氏數列，這在之前有提過；費氏搜尋會先透過公式計算求出第一個要搜尋數的位置，以及其代
表的費氏數，以搜尋對象10個數字來說，第一個費氏數經計算後一定是F5，而第一個要搜尋的位置有兩個可能，例如若在下面的數列搜尋的話（為了計算方便，
通常會將索引0訂作無限小的數，而數列由索引1開始）：<br>

<br>
<span style="font-family: Courier New,Courier,monospace;">
-&infin; 1 3 5 7 9 13 15 17 19 20</span><br>

<br>

如果要搜尋5的話，則由索引F5 = 5開始搜尋，接下來如果數列中的數小於指定搜尋值時，就往左找，大於時就向右，每次找的間隔是F4、F3、F2來尋找，當費氏數為0時還沒找到，就表示尋找失敗，如下所示： <br>


<div style="text-align: center;"><img style="width: 232px; height: 123px;" alt="費式搜尋" title="費式搜尋" src="images/fibonacciSearch-1.jpg"><br>

<br>

<div style="text-align: left;">由於第一個搜尋值索引F5 = 5處的值小於19，所以此時必須對齊數列右方，也就是將第一個搜尋值的索引改為F5+2 = 7，然後如同上述的方式進行搜尋，如下所示：<br>

</div>

<div style="text-align: center;"><img style="width: 234px; height: 138px;" alt="費式搜尋" title="費式搜尋" src="images/fibonacciSearch-2.jpg"></div>

<div style="text-align: left;">至於第一個搜尋值是如何找到的？我們可以由以下這個公式來求得，其中n為搜尋對象的個數：<br>

<div style="margin-left: 40px;"><span style="font-weight: bold; font-family: Courier New,Courier,monospace;">F</span><sub style="font-weight: bold; font-family: Courier New,Courier,monospace;">x</sub><span style="font-weight: bold; font-family: Courier New,Courier,monospace;"> + m = n </span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;">

<span style="font-weight: bold; font-family: Courier New,Courier,monospace;">F</span><sub style="font-weight: bold; font-family: Courier New,Courier,monospace;">x</sub><span style="font-weight: bold; font-family: Courier New,Courier,monospace;"> &lt;= n </span><br>

</div>

&nbsp;<br>

<br>

也就是說Fx必須找到不大於n的費氏數，以10個搜尋對象來說：<br>

<div style="margin-left: 40px;"><span style="font-weight: bold; font-family: Courier New,Courier,monospace;">F</span><sub style="font-weight: bold; font-family: Courier New,Courier,monospace;">x</sub><span style="font-weight: bold; font-family: Courier New,Courier,monospace;"> + m = 10 </span><br>

</div>

&nbsp;<br>

<br>

取F<sub>x</sub> = 8, m = 2，所以我們可以對照費氏數列得x = 6，然而第一個數的可能位置之一並不是F6，而是第x-1的費氏數，也就是F<sub>5</sub> = 5。<br>

<br>

如果數列number在索引5處的值小於指定的搜尋值，則第一個搜尋位置就是索引5的位置，如果大於指定的搜尋值，則第一個搜尋位置必須加上m，也就是F<sub>5</sub> + m = 5 + 2 = 7，也就是索引7的位置，其實加上m的原因，是為了要讓下一個搜尋值剛好是數列的最後一個位置。<br>

<br>

費氏搜尋看來難懂，但只要掌握F<sub>x</sub> + m = n這個公式，自己找幾個實例算一次，很容易就可以理解；費氏搜尋除了收斂快速之外，由於其本身只會使用到加法與減法，在運算上也可以加快。 <br>

</div>

<br>

<div style="text-align: left;">
<h2> 實作</h2>


<ul>

  <li> C
  </li>

</ul>


<pre>#include &lt;stdio.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;time.h&gt; <br>#define MAX 15 <br>#define SWAP(x,y) {int t; t = x; x = y; y = t;} <br><br>void createfib(void);     // 建立費氏數列 <br>int findx(int, int);          // 找x值 <br>int fibsearch(int[], int);  // 費氏搜尋 <br>void quicksort(int[], int, int);  // 快速排序 <br><br>int Fib[MAX] = {-999}; <br><br>int main(void) { <br>    int number[MAX] = {0}; <br>    int i, find; <br><br>    srand(time(NULL)); <br><br>    for(i = 1; i &lt;= MAX; i++) { <br>        number[i] = rand() % 100; <br>    } <br><br>    quicksort(number, 1, MAX); <br><br>    printf("數列："); <br>    for(i = 1; i &lt;= MAX; i++) <br>        printf("%d ", number[i]); <br><br>    printf("\n輸入尋找對象："); <br>    scanf("%d", &amp;find); <br><br>    if((i = fibsearch(number, find)) &gt;= 0) <br>        printf("找到數字於索引 %d ", i); <br>    else <br>        printf("\n找不到指定數"); <br>    <br>    printf("\n"); <br><br>    return 0; <br>} <br><br>// 建立費氏數列 <br>void createfib(void) { <br>    int i; <br><br>    Fib[0] = 0; <br>    Fib[1] = 1; <br><br>    for(i = 2; i &lt; MAX; i++) <br>        Fib[i] = Fib[i-1] + Fib[i-2]; <br>} <br><br>// 找 x 值 <br>int findx(int n, int find) { <br>    int i = 0; <br><br>    while(Fib[i] &lt;= n) <br>        i++; <br><br>    i--; <br>    return i; <br>} <br><br>// 費式搜尋 <br>int fibsearch(int number[], int find) { <br>    int i, x, m; <br><br>    createfib(); <br><br>    x  = findx(MAX+1,find); <br>    m = MAX - Fib[x]; <br>    printf("\nx = %d, m = %d, Fib[x] = %d\n\n", <br>                                     x, m, Fib[x]); <br><br>    x--; <br>    i = x; <br><br>    if(number[i] &lt; find) <br>        i += m; <br><br>    while(Fib[x] &gt; 0) { <br>        if(number[i] &lt; find) <br>            i += Fib[--x]; <br>        else if(number[i] &gt; find) <br>            i -= Fib[--x]; <br>        else <br>            return i; <br>    } <br>    return -1; <br>} <br><br>void quicksort(int number[], int left, int right) { <br>    int i, j, k, s; <br><br>    if(left &lt; right) { <br>        s = number[(left+right)/2]; <br>        i = left - 1; <br>        j = right + 1; <br><br>        while(1) { <br>            while(number[++i] &lt; s) ;  // 向右找 <br>            while(number[--j] &gt; s) ;  // 向左找 <br>            if(i &gt;= j) <br>                break; <br>            SWAP(number[i], number[j]); <br>        } <br><br>        quicksort(number, left, i-1);   // 對左邊進行遞迴 <br>        quicksort(number, j+1, right);  // 對右邊進行遞迴 <br>    } <br>} <br></pre>


<br>


<ul>

  <li> Java
  </li>

</ul>


<pre>public class FibonacciSearch {<br>    public static int search(int[] number, int des) { <br>        int[] fib = createFibonacci(number.length); <br><br>        int x  = findX(fib, number.length+1, des); <br>        int m = number.length - fib[x]; <br>        x--; <br>        int i = x; <br><br>        if(number[i] &lt; des) <br>            i += m; <br><br>        while(fib[x] &gt; 0) { <br>            if(number[i] &lt; des) <br>                i += fib[--x]; <br>            else if(number[i] &gt; des) <br>                i -= fib[--x]; <br>            else <br>                return i; <br>        } <br>        <br>        return -1; <br><br>    }<br>    <br>    private static int[] createFibonacci(int max) {<br>        int[] fib = new int[max];<br>        for(int i = 0; i &lt; fib.length; i++) {<br>            fib[i] = Integer.MIN_VALUE;   <br>        }<br><br>        fib[0] = 0; <br>        fib[1] = 1; <br><br>        for(int i = 2; i &lt; max; i++) <br>            fib[i] = fib[i-1] + fib[i-2];<br>        <br>        return fib;<br>    }<br>    <br>    private static int findX(int[] fib, int n, int des) {<br>        int i = 0; <br><br>        while(fib[i] &lt;= n) <br>            i++; <br><br>        i--; <br>        <br>        return i;     <br>    }<br>    <br>    public static void main(String[] args) {<br>        int[] number = {1, 4, 2, 6, 7, 3, 9, 8};<br>        <br>        QuickSort.sort(number);<br>        <br>        int find = Fibonacci.search(number, 3);<br>        <br>        if(find != -1) <br>            System.out.println("找到數值於索引" + find); <br>        else <br>            System.out.println("找不到數值"); <br>    }<br>}</pre>

<br>

<br>

</div>

</div>





</body>
</html>
