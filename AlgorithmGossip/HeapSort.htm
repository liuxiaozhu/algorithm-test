<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>





  
  
  
  
  
  <link rel="stylesheet" href="css/stdlayout.css" type="text/css">





  
  
  
  
  
  <link rel="stylesheet" href="css/print.css" type="text/css">





  
  
  
  
  
  <meta content="text/html; charset=UTF-8" http-equiv="content-type">





  
  
  
  
  
  <title>Heap 排序法 - 改良的選擇排序</title>
</head>


<body>





<h3><a href="http://caterpillar.onlyfun.net/Gossip/index.html">From
Gossip@caterpillar</a></h3>





<h1><a href="AlgorithmGossip.htm">Algorithm Gossip:&nbsp;Heap 排序法 - 改良的選擇排序</a></h1>





<h2>說明</h2>
選擇排序法的概念簡單，每次從未排序部份選一最小值，插入已排序部份的後端，其時間主要花費於在整個未排序部份尋找最小值，如果能讓搜尋最小值的方式加
快，選擇排序法的速率也就可以加快，Heap排序法讓搜尋的路徑由樹根至最後一個樹葉，而不是整個未排序部份，因而稱之為改良的選擇排序法。<br>
<h2>解法</h2>
Heap排序法使用Heap
Tree（堆積樹），樹是一種資料結構，而堆積樹是一個二元樹，也就是每一個父節點最多只有兩個子節點（關於樹的詳細定義還請見資料結構書籍），堆積樹的
父節點若小於子節點，則稱之為最小堆積（Min Heap），父節點若大於子節點，則稱之為最大堆積（Max
Heap），而同一層的子節點則無需理會其大小關係，例如下面就是一個堆積樹： <br>


<div style="text-align: center;"><img style="width: 284px; height: 152px;" alt="Heap 排序" title="Heap 排序" src="images/heapSort-1.jpg"></div>
<br>
可以使用一維陣列來儲存堆積樹的所有元素與其順序，為了計算方便，使用的起始索引是1而不是0，索引1是樹根位置，如果左子節點儲存在陣列中的索引為s，則其父節點的索引為s/2，而右子節點為s+1，就如上圖所示，將上圖的堆積樹轉換為一維陣列之後如下所示： <br>
<div style="text-align: center;"><img style="width: 286px; height: 55px;" alt="Heap 排序" title="Heap 排序" src="images/heapSort-2.jpg"></div>
<br>
首先必須知道如何建立堆積樹，加至堆積樹的元素會先放置在最後一個樹葉節點位置，然後檢查父節點是否小於子節點（最小堆積），將小的元素不斷與父節點交換，直到滿足堆積樹的條件為止，例如在上圖的堆積加入一個元素12，則堆積樹的調整方式如下所示：<br>
<div style="text-align: center;"><img style="width: 574px; height: 154px;" alt="Heap 排序" title="Heap 排序" src="images/heapSort-3.jpg"></div>
<br>
建立好堆積樹之後，樹根一定是所有元素的最小值，您的目的就是：<br>
<ol>
  <li>將最小值取出</li>
  <li>然後調整樹為堆積樹</li>
</ol>
<br>
不斷重複以上的步驟，就可以達到排序的效果，最小值的取出方式是將樹根與最後一個樹葉節點交換，然後切下樹葉節點，重新調整樹為堆積樹，如下所示： <br>
<div style="text-align: center;"><img style="width: 591px; height: 199px;" alt="Heap 排序" title="Heap 排序" src="images/heapSort-4.jpg"></div>
<br>

調整完畢後，樹根節點又是最小值了，於是我們可以重覆這個步驟，再取出最小值，並調整樹為堆積樹，如下所示：<br>
<div style="text-align: center;"><img style="width: 564px; height: 197px;" alt="Heap 排序" title="Heap 排序" src="images/heapSort-5.jpg"></div>
<br>

如此重覆步驟之後，由於使用一維陣列來儲存堆積樹，每一次將樹葉與樹根交換的動作就是將最小值放至後端的陣列，所以最後陣列就是變為已排序的狀態。
<br>

<br>
其實堆積在調整的過程中，就是一個選擇的行為，每次將最小值選至樹根，而選擇的路徑並不是所有的元素，而是由樹根至樹葉的路徑，因而可以加快選擇的過程，
所以Heap排序法才會被稱之為改良的選擇排序法。 <br>
<h2> 實作</h2>

<ul>
  <li> C
  </li>
</ul>

<pre>#include &lt;stdio.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;time.h&gt; <br>#define MAX 10 <br>#define SWAP(x,y) {int t; t = x; x = y; y = t;} <br><br>void createheap(int[]); <br>void heapsort(int[]); <br><br>int main(void) { <br>    int number[MAX+1] = {-1}; <br>    int i, num;  <br><br>    srand(time(NULL)); <br><br>    printf("排序前："); <br>    for(i = 1; i &lt;= MAX; i++) { <br>        number[i] = rand() % 100; <br>        printf("%d ", number[i]); <br>    } <br><br>    printf("\n建立堆積樹："); <br>    createheap(number); <br>    for(i = 1; i &lt;= MAX; i++) <br>        printf("%d ", number[i]); <br>    printf("\n"); <br><br>    heapsort(number); <br><br>    printf("\n"); <br><br>    return 0; <br>} <br><br>void createheap(int number[]) { <br>    int i, s, p; <br>    int heap[MAX+1] = {-1}; <br><br>    for(i = 1; i &lt;= MAX; i++) { <br>        heap[i] = number[i]; <br>        s = i; <br>        p = i / 2; <br>        while(s &gt;= 2 &amp;&amp; heap[p] &gt; heap[s]) { <br>            SWAP(heap[p], heap[s]); <br>            s = p; <br>            p = s / 2; <br>        } <br>    } <br><br>    for(i = 1; i &lt;= MAX; i++) <br>        number[i] = heap[i]; <br>    <br>} <br><br>void heapsort(int number[]) { <br>    int i, m, p, s; <br><br>    m = MAX; <br>    while(m &gt; 1) { <br>        SWAP(number[1], number[m]); <br>        m--; <br><br>        p = 1; <br>        s = 2 * p; <br><br>        while(s &lt;= m) { <br>            if(s &lt; m &amp;&amp; number[s+1] &lt; number[s]) <br>                s++; <br>            if(number[p] &lt;= number[s]) <br>                break; <br>            SWAP(number[p], number[s]); <br>            p = s; <br>            s = 2 * p; <br>        } <br><br>        printf("\n排序中："); <br>        for(i = MAX; i &gt; 0; i--) <br>            printf("%d ", number[i]); <br>    } <br>} <br></pre>

<br>

<ul>
  <li> Java
  </li>
</ul>

<pre>public class HeapSort {<br>    public static void sort(int[] number) {<br>        int[] tmp = new int[number.length + 1];<br>        <br>        // 配合說明，使用一個有&#24487;移的暫存陣列<br>        for(int i = 1; i &lt; tmp.length; i++) {<br>            tmp[i] = number[i-1];   <br>        }<br>        <br>        createHeap(tmp);<br>        <br>        int m = number.length; <br>        while(m &gt; 1) { <br>            swap(tmp, 1, m); <br>            m--; <br><br>            int p = 1; <br>            int s = 2 * p; <br><br>            while(s &lt;= m) { <br>                if(s &lt; m &amp;&amp; tmp[s+1] &lt; tmp[s]) <br>                    s++; <br>                if(tmp[p] &lt;= tmp[s]) <br>                    break; <br>                swap(tmp, p, s); <br>                p = s; <br>                s = 2 * p; <br>            } <br>        } <br>        <br>        // 這邊將排序好的暫存陣列設定回原陣列<br>        for(int i = 0; i &lt; number.length; i++) {<br>            number[i] = tmp[i+1];   <br>        }<br>    }<br>    <br>    private static void createHeap(int[] tmp) { <br>        int[] heap = new int[tmp.length];<br>        <br>        for(int i = 0; i &lt; heap.length; i++)<br>            heap[i] = -1;<br><br>        for(int i = 1; i &lt; heap.length; i++) { <br>            heap[i] = tmp[i]; <br>            int s = i; <br>            int p = i / 2; <br>            while(s &gt;= 2 &amp;&amp; heap[p] &gt; heap[s]) { <br>                swap(heap, p, s); <br>                s = p; <br>                p = s / 2; <br>            } <br>        } <br><br>        for(int i = 1; i &lt; tmp.length; i++) <br>            tmp[i] = heap[i]; <br>        <br>    } <br>    <br>    private static void swap(int[] number, int i, int j) {<br>        int t; <br>        t = number[i]; <br>        number[i] = number[j]; <br>        number[j] = t;<br>    }<br>} </pre>
<br>
<br>





</body>
</html>
