<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>




  
  
  
  
  <link rel="stylesheet" href="css/stdlayout.css" type="text/css">




  
  
  
  
  <link rel="stylesheet" href="css/print.css" type="text/css">




  
  
  
  
  <meta content="text/html; charset=UTF-8" http-equiv="content-type">




  
  
  
  
  <title>選擇、插入、氣泡排序</title>
</head>


<body>




<h3><a href="http://caterpillar.onlyfun.net/Gossip/index.html">From
Gossip@caterpillar</a></h3>




<h1><a href="AlgorithmGossip.htm">Algorithm Gossip:&nbsp;選擇、插入、氣泡排序</a></h1>




<h2>說明</h2>
選擇排序（Selection sort）、插入排序（Insertion sort）與氣泡排序（Bubble sort）這三個排序方式是初學排序所必須知道的三個基本排序方式，它們由於速度不快而不實用（平均與最快的時間複雜度都是O(n<sup>2</sup>)），然而它們排序的方式確是值得觀察與探討的。<br>
<h2>解法</h2>
<ul>
  <li>選擇排序</li>
</ul>
<div style="margin-left: 40px;">將要排序的對象分作兩部份，一個是已排序的，一個是未排序的，從後端未排序部份選擇一個最小值，並放入前端已排序部份的最後一個，例如：<br>
</div>
<br>
<div style="margin-left: 40px;">排序前：70 80 31 37 10 1 48 60 33 80<br>
<br>
<ol>
  <li>[1] 80 31 37 10 70 48 60 33 80 選出最小值1</li>
  <li>[1 10] 31 37 80 70 48 60 33 80 選出最小值10</li>
  <li>[1 10 31] 37 80 70 48 60 33 80 選出最小值31</li>
  <li>[1 10 31 33] 80 70 48 60 37 80 ......</li>
  <li>[1 10 31 33 37] 70 48 60 80 80 ......</li>
  <li>[1 10 31 33 37 48] 70 60 80 80 ......</li>
  <li>[1 10 31 33 37 48 60] 70 80 80 ......</li>
  <li>[1 10 31 33 37 48 60 70] 80 80 ......</li>
  <li>[1 10 31 33 37 48 60 70 80] 80 ......</li>
</ol>
</div>
<br>
<ul>
  <li>插入排序</li>
</ul>
<div style="margin-left: 40px;">像是玩樸克一樣，我們將牌分作兩堆，每次從後面一堆的牌抽出最前端的牌，然後插入前面一堆牌的適當位置，例如：<br>
</div>
<br>
<div style="margin-left: 40px;">排序前：92 77 67 8 6 84 55 85 43 67<br>
<br>
<ol>
  <li>[77 92] 67 8 6 84 55 85 43 67 將77插入92前</li>
  <li>[67 77 92] 8 6 84 55 85 43 67 將67插入77前</li>
  <li>[8 67 77 92] 6 84 55 85 43 67 將8插入67前</li>
  <li>[6 8 67 77 92] 84 55 85 43 67 將6插入8前</li>
  <li>[6 8 67 77 84 92] 55 85 43 67 將84插入92前</li>
  <li>[6 8 55 67 77 84 92] 85 43 67 將55插入67前</li>
  <li>[6 8 55 67 77 84 85 92] 43 67 ......</li>
  <li>[6 8 43 55 67 77 84 85 92] 67 ......</li>
  <li>[6 8 43 55 67 67 77 84 85 92] ......</li>
</ol>
</div>
<br>
<ul>
  <li>氣泡排序法</li>
</ul>
<div style="margin-left: 40px;">顧名思義，就是排序時，最大的元素會如同氣泡一樣移至右端，其利用比較相鄰元素的方法，將大的元素交換至右端，所以大的元素會不斷的往右移動，直到適當的位置為止。<br>
</div>
<div style="margin-left: 40px;"><br>
基本的氣泡排序法可以利用旗標的方式稍微減少一些比較的時間，當尋訪完陣列後都沒有發生任何的交換動作，表示排序已經完成，而無需再進行之後的迴圈比較與交換動作，例如：<br>
<br>
排序前：95 27 90 49 80 58 6 9 18 50<br>
<br>
<ol>
  <li>27 90 49 80 58 6 9 18 50 [95] 95浮出</li>
  <li>27 49 80 58 6 9 18 50 [90 95] 90浮出</li>
  <li>27 49 58 6 9 18 50 [80 90 95] 80浮出</li>
  <li>27 49 6 9 18 50 [58 80 90 95] ......</li>
  <li>27 6 9 18 49 [50 58 80 90 95] ......</li>
  <li>6 9 18 27 [49 50 58 80 90 95] ......</li>
  <li>6 9 18 [27 49 50 58 80 90 95] 由於接下來不會再發生交換動作，排序提早結束</li>
</ol>
<br>
在上面的例子當中，還加入了一個觀念，就是當進行至i與i+1時沒有交換的動作，表示接下來的i+2至n已經排序完畢，這也增進了氣泡排序的效率。 <br>
</div>

<br>
<h2> 實作</h2>

<ul>
  <li> C
  </li>
</ul>

<pre>#include &lt;stdio.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;time.h&gt; <br>#define MAX 10 <br>#define SWAP(x,y) {int t; t = x; x = y; y = t;} <br><br>void selsort(int[]);  // 選擇排序 <br>void insort(int[]);   // 插入排序 <br>void bubsort(int[]);  // 氣泡排序 <br><br>int main(void) {  <br>    int number[MAX] = {0}; <br>    int i;  <br><br>    srand(time(NULL)); <br><br>    printf("排序前："); <br>    for(i = 0; i &lt; MAX; i++) { <br>        number[i] = rand() % 100; <br>        printf("%d ", number[i]); <br>    } <br><br>    printf("\n請選擇排序方式：\n"); <br>    printf("(1)選擇排序\n(2)插入排序\n(3)氣泡排序\n:"); <br>    scanf("%d", &amp;i); <br><br>    switch(i) { <br>        case 1: <br>            selsort(number); break; <br>        case 2: <br>            insort(number); break; <br>        case 3: <br>            bubsort(number); break; <br>        default: <br>            printf("選項錯誤(1..3)\n"); <br>    } <br><br>    return 0; <br>} <br><br>void selsort(int number[]) { <br>    int i, j, k, m; <br><br>    for(i = 0; i &lt; MAX-1; i++) { <br>        m = i; <br>        for(j = i+1; j &lt; MAX; j++) <br>            if(number[j] &lt; number[m]) <br>                m = j; <br><br>        if( i != m) <br>            SWAP(number[i], number[m]) <br><br>        printf("第 %d 次排序：", i+1); <br>        for(k = 0; k &lt; MAX; k++) <br>            printf("%d ", number[k]); <br>        printf("\n"); <br>    } <br> } <br><br> void insort(int number[]) { <br>    int i, j, k, tmp; <br><br>    for(j = 1; j &lt; MAX; j++) { <br>        tmp = number[j]; <br>        i = j - 1; <br>        while(tmp &lt; number[i]) { <br>            number[i+1] = number[i]; <br>            i--; <br>            if(i == -1) <br>                break; <br>        } <br>        number[i+1] = tmp; <br><br>        printf("第 %d 次排序：", j); <br>        for(k = 0; k &lt; MAX; k++) <br>            printf("%d ", number[k]); <br>        printf("\n"); <br>    } <br>} <br><br>void bubsort(int number[]) { <br>    int i, j, k, flag = 1; <br><br>    for(i = 0; i &lt; MAX-1 &amp;&amp; flag == 1; i++) { <br>        flag = 0; <br>        for(j = 0; j &lt; MAX-i-1; j++) { <br>            if(number[j+1] &lt; number[j]) { <br>                SWAP(number[j+1], number[j]); <br>                flag = 1; <br>            } <br>        } <br><br>        printf("第 %d 次排序：", i+1); <br>        for(k = 0; k &lt; MAX; k++) <br>            printf("%d ", number[k]); <br>        printf("\n"); <br>    } <br>} <br></pre>

<p></p>

<ul>
  <li> Java
  </li>
</ul>

<pre>public class BasicSort {<br>    public static void selectionSort(int[] number) {<br>        for(int i = 0; i &lt; number.length - 1; i++) { <br>            int m = i; <br>            for(int j = i + 1; j &lt; number.length; j++) <br>                if(number[j] &lt; number[m]) <br>                    m = j; <br><br>            if(i != m) <br>                swap(number, i, m);<br>        }<br>    }<br>    <br>    public static void injectionSort(int[] number) { <br>        for(int j = 1; j &lt; number.length; j++) { <br>            int tmp = number[j]; <br>            int i = j - 1; <br>            while(tmp &lt; number[i]) {<br>                number[i+1] = number[i]; <br>                i--; <br>                if(i == -1) <br>                    break; <br>            } <br>            <br>            number[i+1] = tmp; <br>        } <br>    }<br>    <br>    public static void bubbleSort(int[] number) {<br>        boolean flag = true; <br><br>        for(int i = 0; i &lt; number.length-1 &amp;&amp; flag; i++) { <br>            flag = false; <br>            for(int j = 0; j &lt; number.length-i-1; j++) { <br>                if(number[j+1] &lt; number[j]) { <br>                    swap(number, j+1, j); <br>                    flag = true; <br>                } <br>            } <br>        }<br>    }<br>    <br>    private static void swap(int[] number, int i, int j) {<br>        int t; <br>        t = number[i]; <br>        number[i] = number[j]; <br>        number[j] = t;<br>    }<br>}<br></pre>
<br>




</body>
</html>
